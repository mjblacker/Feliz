---
title: Output JSX
description: A guide on how to use JSX output in Feliz with Fable.
sidebar_position: 2
toc_max_heading_level: 4
---

import ComponentRender from '@site/src/components/ComponentRender';
import ReactReference from '@site/src/components/ReactRefAdmonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

export const FableVersion = "5.0.0-alpha.14"

:::danger[Change file extension]
If you want to use JSX output you need to change the file extension of your transpiled files to `*.jsx`. This is required for the JSX output to be correctly interpreted by bundlers like webpack or tools like eslint. You can do this by updating your Fable transpile command:

```bash
dotnet fable Example.fsproj -e .jsx
```

This does not impact your ability to use the established Feliz API, which will still work as expected in `*.jsx` files.
:::

Currently, the default way for Feliz to create React Elements is through `React.createElement`. This allows us to fully leverage f# list expression syntax and makes it easy to create elements dynamically. However, using modern JSX output makes the transpiled code more readable and easier to debug, and might lead to performance increases.

<ReactReference href="https://react.dev/reference/react/createElement" name="createElement" />

Thanks to the awesome work of the Fable team (big shoutout to [@MangelMaxime](https://github.com/MangelMaxime)), the support for JSX output was greatly increased. And there are two ways to use it in Feliz. One is the `Feliz.JSX` module, which provides a similar API to the existing `Feliz` module, but outputs JSX. The other is through template strings, which allow you to write JSX directly in your F# code.

In my opinion this feature is still experimental, and it might be best to mix and match between the existing Feliz API and the new JSX output, depending on your needs. But it's definitely worth exploring!

## Using the JSX module

The `Feliz.JSX` module uses Fables `JSX.create` function to output JSX. This abstraction from `JSX.create` to JSX output is done directly on the Fable compiler level, resulting in a very clean output.

If you want to give it a try you can `open Feliz.JSX` in your file. This will shadow the existing `Html.*` so you can easily switch between the two.

Below you can find an example for using the `Feliz.JSX` module. It fully duplicates the syntax from the default `Html.*` type. Make sure to check out the transpiled outputs!

import JSXModule from '../../feliz-docs/fableoutput/Examples/Guides/JSXModule'
import RawJSXModule from '!!raw-loader!../../feliz-docs/Examples/Guides/JSXModule.fs'
import RawJSXModuleJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Guides/JSXModule.jsx'

export const FileOutput = `
import { createElement, useState } from "react";
import React from "react";
import { HtmlHelper_createElement } from "../../src/Feliz/Html.jsx";
import { defaultOf } from "../../fable_modules/fable-library-js.5.0.0-alpha.14/Util.js";
import { ofArray } from "../../fable_modules/fable-library-js.5.0.0-alpha.14/List.js";
import { map, singleton, delay, toList } from "../../fable_modules/fable-library-js.5.0.0-alpha.14/Seq.js";
import { printf, toText } from "../../fable_modules/fable-library-js.5.0.0-alpha.14/String.js";
import { rangeDouble } from "../../fable_modules/fable-library-js.5.0.0-alpha.14/Range.js";

export function TestComponent() {
    let children_11, children_8;
    const patternInput = useState(0);
    const setCounter = patternInput[1];
    const counter = patternInput[0] | 0;
    return HtmlHelper_createElement("div", ofArray([["id", "my-div"], ["className", "container"], ["children", [createElement("h1", defaultOf(), "Hello from JSX!"), createElement("p", defaultOf(), "This is a paragraph inside a div."), (children_11 = ofArray([createElement("h1", defaultOf(), "Counter - Reactivity Test"), HtmlHelper_createElement("button", ofArray([["children", "Increment"], ["onClick", (_arg) => {
        setCounter(counter + 1);
    }]])), (children_8 = toList(delay(() => ((counter === 0) ? singleton(createElement("li", defaultOf(), "No items")) : map((i) => HtmlHelper_createElement("li", ofArray([["key", i], ["children", toText(printf("Item %d"))(i)]])), rangeDouble(1, 1, counter))))), createElement("ul", defaultOf(), ...children_8))]), createElement("div", defaultOf(), ...children_11))]]]));
}

export default TestComponent;
`

<ComponentRender code={[
  { language: 'fsharp', content: RawJSXModule, fileName: 'JSX.fs' },
  { language: 'jsx', content: RawJSXModuleJSX, fileName: 'JSXOutout.jsx' },
  { language: 'js', content: FileOutput, fileName: 'DefaultOutput.js' }
]} defaultOpen> 
  <JSXModule />
</ComponentRender>


### Alias the Feliz.JSX module

If you want to mix both JSX output and previous output in one file you can alias the module:

```fsharp
type Jsx = Feliz.JSX.Html

Jsx.div [
    Jsx.h1 "Hello from JSX!"
    Jsx.p "This is a paragraph inside a div."
]
```

import JSXAlias from '../../feliz-docs/fableoutput/Examples/Guides/JSXModuleAlias'
import RawJSXAlias from '!!raw-loader!../../feliz-docs/Examples/Guides/JSXModuleAlias.fs'
import RawJSXAliasJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Guides/JSXModuleAlias.jsx'

<ComponentRender code={[
  { language: 'fsharp', content: RawJSXAlias, fileName: 'JSXAlias.fs' },
  { language: 'jsx', content: RawJSXAliasJSX, fileName: 'JSXAlias.jsx' },
]} defaultOpen> 
  <JSXAlias />
</ComponentRender>

### FAQ

These FAQs are errors or issues that you might encounter when using the JSX module. (Tested for Fable version {FableVersion}).

#### `match ... with` in children üêõ

Using `match ... with` directly inside `prop.children` is currently not correctly handled by the fable compiler and will lead to runtime errors. A workaround is to use `if` syntax instead or to bind the result of the match to a variable first.

:::info
Tracked in this [GitHub issue](
https://github.com/fable-compiler/Fable/issues/4224).
:::

<Tabs>

<TabItem value="error" label="Error: match ... with">

```fsharp
[<ReactComponent(true)>]
let TestComponent() =
    let counter, setCounter = React.useState(0)
    Html.ul [
        match counter with
        | 0 ->  Html.li "No items!" 
        | items -> 
            for i in 1..items do
                Html.li [
                    prop.key i 
                    prop.text (sprintf "Item %d" i) 
                ]
    ]
```

</TabItem>

<TabItem value="if" label="Workaround: if ... else">

```fsharp
Html.ul [
    if counter = 0 then
        Html.li "No items"
    else
        for i in 1..counter do
            Html.li [
                prop.key i 
                prop.text (sprintf "Item %d" i) 
            ]
]

```

</TabItem>

<TabItem value="let" label="Workaround: let">

```fsharp

let ChildList = 
    match counter with
    | 0 ->
        Html.li "No items"
    | items ->
        React.Fragment [
            for i in 1..items do
                Html.li [
                    prop.key i 
                    prop.text (sprintf "Item %d" i) 
                ]
        ]

Html.ul [
    ChildList
]
```

</TabItem>

</Tabs>

#### conditional properties ‚ö†Ô∏è

`error FABLE: Expecting a static list or array literal (no generator) for JSX props`

:::info
Tracked in this [GitHub issue](
https://github.com/fable-compiler/Fable/issues/4119).
:::

You might encounter issues when using conditional properties.

In Feliz you normally can do conditional properties in any way F# list syntax allows.

```fsharp
Html.div [
    if isActive then prop.custom("data-active", true) 
    if isDisabled then prop.className "disabled"
]
```

This does currently not work in JSX syntax. This issue arises due to JSX output syntax where conditional properties are done like this:

```jsx
<div>
  data-active={isActive ? true : undefined}
  className={isDisabled ? "disabled" : undefined}
</div>
```

Following this line of thought, in which the property key is always present we need to shift the conditional inside the property value. So the correct way to do conditional properties in JSX syntax is:

```fsharp
Html.div [
    prop.custom("data-active", isActive)
    prop.className(if isDisabled then "disabled" else "")
]
```

## Using template strings

:::info
This is based on the following [blog post](https://fable.io/blog/2022/2022-10-12-react-jsx.html) by [@alfonsogcnunez](https://x.com/alfonsogcnunez)
:::

Using f# template strings you can write JSX directly in your f# code. The syntax used is very similiar to the one introduced by [Lit](https://lit.dev/docs/templates/overview/), which is a popular library for building web components. 

We use `Html.jsx $""" .. """` to define a JSX template. Inside the template you can use `${ ... }` to insert f# expressions.

import JSXTemplate from '../../feliz-docs/fableoutput/Examples/Guides/JSXTemplate'
import RawJSXTemplate from '!!raw-loader!../../feliz-docs/Examples/Guides/JSXTemplate.fs'
import RawJSXTemplateJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Guides/JSXTemplate.jsx'

<ComponentRender code={[
  { language: 'fsharp', content: RawJSXTemplate, fileName: 'RawJSXTemplate.fs' },
  { language: 'jsx', content: RawJSXTemplateJSX, fileName: 'RawJSXTemplate.jsx' },
]} defaultOpen> 
  <JSXTemplate />
</ComponentRender>

### Editor support

To get syntax highlighting and intellisense support in VSCode you can use the plugin [Highlight templates in F#](https://marketplace.visualstudio.com/items?itemName=alfonsogarciacaro.vscode-template-fsharp-highlight).

:::danger
Make sure to follow the exact syntax for template strings to get hightlighting and intellisense support.

```fsharp
// This must be one line with a linebreak after the $"""
Html.jsx $""" 
  <div>
    <h1>Hello from JSX Template!</h1>
    <p>This is a paragraph inside a div.</p>
  </div>
"""
// The closing """ must be on a new line
```
