---
title: "[<ReactComponent>]"
sidebar_position: 5
---

import ComponentRender from '@site/src/components/ComponentRender';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import Admonition from '@theme/Admonition';

Feliz offers a simple way to define React components using the `[<ReactComponent>]` attribute. This attribute can be applied to a function that returns a React element.

With the help of `[<ReactComponent>]` Feliz can ensure that the components are correctly transformend and called after transpilation to JavaScript.

:::info

If you are interested in what happens under the hood, here is a short summary of notable points:

<details>
<summary>Click to expand</summary>

import RawTupled from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactComponentTransform/Tupled.fs'
import RawTupledJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactComponentTransform/Tupled.jsx'

import RawCurried from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactComponentTransform/Curried.fs'
import RawCurriedJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactComponentTransform/Curried.jsx'

import RawRecordType from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactComponentTransform/RecordType.fs'
import RawRecordTypeJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactComponentTransform/RecordType.jsx'

import RawAnonymRecordType from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactComponentTransform/AnonymRecordType.fs'
import RawAnonymRecordTypeJSX from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactComponentTransform/AnonymRecordType.jsx'

- Transform all arguments into an JavaScript object.
  
  Tupled/curried arguments are transformed into object and exactly one argument as **anonymous** record type will be used as object.

    <details>
    <summary>Example: Tupled arguments</summary>

    <Tabs>

    <TabItem value="fsharp" label="F#">

    <CodeBlock language='fsharp'>
    {RawTupled}
    </CodeBlock>

    </TabItem>

    <TabItem value="jsx" label="jsx">

    <CodeBlock language='jsx'>
    {RawTupledJSX}
    </CodeBlock>

    </TabItem>

    </Tabs>

    </details>

    <details>
    <summary>Example: Curried arguments</summary>

    <Tabs>

    <TabItem value="fsharp" label="F#">

    <CodeBlock language='fsharp'>
    {RawCurried}
    </CodeBlock>

    </TabItem>

    <TabItem value="jsx" label="jsx">

    <CodeBlock language='jsx'>
    {RawCurriedJSX}
    </CodeBlock>

    </TabItem>

    </Tabs>

    </details>

    <details>
    <summary>Example: Anonymous Record Type</summary>

    <Tabs>

    <TabItem value="fsharp" label="F#">

    <CodeBlock language='fsharp'>
    {RawAnonymRecordType}
    </CodeBlock>

    </TabItem>

    <TabItem value="jsx" label="jsx">

    <CodeBlock language='jsx'>
    {RawAnonymRecordTypeJSX}
    </CodeBlock>

    </TabItem>

    </Tabs>

    </details>

    <details>
    <summary>Example: Record Type ⚠️</summary>

    <Admonition type="warning">
      Record types are not transformed and passed as is. Record Types are transpiled by Fable into a class like structure so we loose equality and possibly attached functions if we deconstruct them into a js object.
    </Admonition>

    <Tabs>

    <TabItem value="fsharp" label="F#">

    <CodeBlock language='fsharp'>
    {RawRecordType}
    </CodeBlock>

    </TabItem>

    <TabItem value="jsx" label="jsx">

    <CodeBlock language='jsx'>
    {RawRecordTypeJSX}
    </CodeBlock>

    </TabItem>

    </Tabs>

    </details>

- Component will be called using the `createElement` function from React.
- Import `React` automatically.

</details>

:::

## export default

You can pass a boolean parameter to the attribute to export the component as the default export of the module.

```fsharp
[<ReactComponent(exportDefault = true)>]
let Component() = ...
// or 

[<ReactComponent(true)>]
let Component() = ...
```

## import .. from

You can pass string arguments to the attribute to import specific named imports from a file.

:::danger
For file imports use relative paths only! They MUST start with `./` or `../`! Otherwise Fable might not be able to resolve the path correctly
:::

```fsharp
[<ReactComponent(import = "Counter", from = "../Counter")>] // from file
let Component() = React.Imported()

[<ReactComponent(import = "Counter", from = "my-awesome-counter")>] // from node_modules
let Component() = React.Imported()
```


import RawNativeCounter from '!!raw-loader!../../feliz-docs/Examples/Feliz/NativeCounter.tsx'
import RawReactComponentImport from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactComponentImport.fs'
import ReactComponentImport from '../../feliz-docs/fableoutput/Examples/Feliz/ReactComponentImport'

<ComponentRender code={[
  {fileName: 'NativeCounter.tsx', content: RawNativeCounter, language: 'tsx'},
  {fileName: 'ReactComponentImport.fs', content: RawReactComponentImport, language: 'fsharp'}
]} defaultOpen>
  <ReactComponentImport />
</ComponentRender>

## `[<ReactMemoComponent>]`

React `memo` components can be created using the `[<ReactMemoComponent>]` attribute. It works the same way as `[<ReactComponent>]`, but wraps the component in `React.memo` and ensures that it is defined as a `const` in the generated JavaScript code.

import MemoAttribute from '../../feliz-docs/fableoutput/Examples/React/MemoAttribute'
import RawMemoAttribute from '!!raw-loader!../../feliz-docs/Examples/React/MemoAttribute.fs'

<ComponentRender code={RawMemoAttribute}>
  <MemoAttribute />
</ComponentRender>

### areEqual - Feliz predefined functions

Feliz features prewritten equality functions for common scenarios that can be used with the `areEqualFn` parameter of the `[<ReactMemoComponent>]` attribute. This parameter
accepts an integer value that corresponds to the desired equality function:

- `0`/`AreEqualFn.FsEquals` - Uses F#'s built-in equality comparison (`=`) for all props. So everything that normally returns true when using F# equality `=` will return true here as well.
- `1`/`AreEqualFn.FsEqualsButFunctions` - Uses F#'s built-in equality comparison (`=`) for all props, but ignores all functions in props. This is useful when you have functions as props that are recreated on each render, but you want to ignore them for equality checks.

You can also use defined integer constants for example: `AreEqualFn.FsEquals` for better readability.

import MemoAttributeAreEqualFn from '../../feliz-docs/fableoutput/Examples/Feliz/ReactMemoComponentAreEqualFn'
import RawMemoAttributeAreEqualFn from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactMemoComponentAreEqualFn.fs'

<ComponentRender code={RawMemoAttributeAreEqualFn} defaultOpen>
  <MemoAttributeAreEqualFn />
</ComponentRender>

### areEqual - JavaScript code emit

You can pass a custom equality function to the `[<ReactMemoComponent>]` attribute using the `areEqual` parameter. The value must be a JavaScript function expressed as a string. This function will be used to determine whether the component should re-render based on its props.

```fsharp
[<ReactMemoComponent("(prevProps, nextProps) => 
    prevProps.fruits.length === nextProps.fruits.length 
    && prevProps.fruits.every((value, index) => 
        value === nextProps.fruits[index]
    )"
)>]
let RenderTextWithEffect (fruits: string []) =
```

This behavior is similiar to the `[<Emit>]` attribute in Fable. 

:::info
`areEqual` is implemented using the `[<StringSyntax("javascript")>]` attribute. This will provide syntax highlighting and basic validation in supported editors.

<details>
<summary>Example: Rider</summary>


import RiderStringSyntax from '../../../static/img/rider-stringsyntax-attribute.png'

<img src={RiderStringSyntax} alt="Rider StringSyntax Attribute" />;


</details>

:::

:::danger
The areEqual functions runs on the transformed js output, so you must assume, that your params are passed as a single object containing all props!
:::

import MemoAttributeAreEqualEmit from '../../feliz-docs/fableoutput/Examples/React/MemoAttributeAreEqualEmit'
import RawMemoAttributeAreEqualEmit from '!!raw-loader!../../feliz-docs/Examples/React/MemoAttributeAreEqualEmit.fs'

<ComponentRender code={RawMemoAttributeAreEqualEmit}>
  <MemoAttributeAreEqualEmit />
</ComponentRender>

### areEqual - F# function call emit

We can also emit a call to a f# function defined in the same file. This function must have the correct signature to be used as an equality function.

```fsharp
let areEqualFn prop1 prop2 =
    prop1 = prop2

[<ReactMemoComponent(nameof areEqualFn)>] // or "areEqualFn"
let RenderTextWithEffect (fruits: string []) =
    React.useEffect (fun () -> console.log("Rerender!") )
    Html.div [ 
        prop.text (fruits |> String.concat ", "); 
        prop.testId "memo-attribute" 
    ]
```

:::info
This works as f# equality does not check reference equality for arrays and sequences, but checks the content of them. Which is what is used by shallow comparison of React.memo.
:::

:::danger
The areEqual functions runs on the transformed js output, so you must assume, that your params are passed as a single object containing all props!

In the example above, if you want to compare the `fruits` prop, you need to access it as `prop1.fruits` and `prop2.fruits` in the `areEqualFn` function:

```fsharp
let areEqualFn (prop1: {|fruits: string []|}) (prop2: {|fruits: string []|}) =
    prop1.fruits = prop2.fruits
```
:::

:::danger[Name Mangling]
If you define your equality function as static member or inside a module, Fable might mangle the name of the function during transpilation. In this case, you need to provide the mangled name to the `areEqual` parameter. You can see this behavior int his [Fable Repl](https://fable.io/repl/#?code=PYBwpgdgBAYghgIwDZgHQGFgCcwChcC2wAJgK4pQCiAjqXEgJYAuAnjNALy5Q9QpNQ4OGnSTsoILKACMEqSABMULr1VyZy9Yvz8oAD00Q4BMMABmVWvWZsIqIWBH1xAehdQAzgAtg5YlAQwAC5LURt2AH0HJzEIfFZwUOtWdnQkOA8PWRVeDyY4JgYAYygTAkCsQWErWK1ZSVAlHLU6zQbtXF0WQ2NTCxjwiDSMrPtq0Vd3AZSh9MzpKPHnCCA&html=Q&css=Q).

```fsharp
module EqualityFn =
    let areEqualFn prop1 prop2 =
        prop1 = prop2
```
:::

import MemoAttributeAreEqualFnEmit from '../../feliz-docs/fableoutput/Examples/React/MemoAttributeAreEqualEmitFnName'
import RawMemoAttributeAreEqualFnEmit from '!!raw-loader!../../feliz-docs/Examples/React/MemoAttributeAreEqualEmitFnName.fs'
import RawMemoAttributeAreEqualFnEmitJS from '!!raw-loader!../../feliz-docs/fableoutput/Examples/React/MemoAttributeAreEqualEmitFnName.jsx'

<ComponentRender code={[{language: 'fsharp', fileName: 'MemoAttributeAreEqualEmitFnName.fs', content: RawMemoAttributeAreEqualFnEmit}, {language: 'jsx', fileName: 'MemoAttributeAreEqualEmitFnName.jsx', content: RawMemoAttributeAreEqualFnEmitJS}]}>
  <MemoAttributeAreEqualFnEmit />
</ComponentRender>

## `[<ReactLazyComponent>]`

React `lazy` components can be created using the `[<ReactLazyComponent>]` attribute. It works similarly to `[<ReactComponent>]`, but is intended for components that are loaded dynamically using `React.lazy`. 

There are two ways to define a lazy component with `[<ReactLazyComponent>]`:

:::info
Remember that only default exports can be lazy loaded!

```fsharp
[<ReactComponent(true)>] // like this!
```
:::

### From existing component

This approach allows to wrap an existing component in a lazy-loaded component.

If you have optional parameters, you will need to add the arguments you want to use to the wrapper. Otherwise the F# compiler will assume a None for all. (See examples below!)

import RawLazy from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactLazyComponent.fs'
import RawLazyTranspiled from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactLazyComponent.jsx'
import RawLists from '!!raw-loader!../../feliz-docs/Examples/Feliz/RenderingLists.fs'

<Tabs>
<TabItem value="F#" label="F#">

<CodeBlock language='fsharp'>
{RawLazy}
</CodeBlock>

</TabItem>

<TabItem value="JSX" label="JSX">

<CodeBlock language='fsharp'>
{RawLazyTranspiled}
</CodeBlock>

</TabItem>

<TabItem value="F#-lists" label="F# List Component">

<CodeBlock language='fsharp'>
{RawLists}
</CodeBlock>

</TabItem>

</Tabs>

### From path

Alternatively you can specify a path to a module that contains a default export of a React component.

:::warning
This approach will not have type safety for the component props! It is similiar to writing a JavaScript binding!
:::

import RawLazyPath from '!!raw-loader!../../feliz-docs/Examples/Feliz/ReactLazyComponentPath.fs'
import RawLazyPathTranspiled from '!!raw-loader!../../feliz-docs/fableoutput/Examples/Feliz/ReactLazyComponentPath.jsx'

<Tabs>
<TabItem value="F#" label="F#">

<CodeBlock language='fsharp'>
{RawLazyPath}
</CodeBlock>

</TabItem>

<TabItem value="JSX" label="JSX">

<CodeBlock language='fsharp'>
{RawLazyPathTranspiled}
</CodeBlock>

</TabItem>

<TabItem value="F#-lists" label="F# List Component">

<CodeBlock language='fsharp'>
{RawLists}
</CodeBlock>

</TabItem>

</Tabs>
