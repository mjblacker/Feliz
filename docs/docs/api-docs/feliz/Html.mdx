---
title: Html
sidebar_position: 0
---

import ComponentRender from '@site/src/components/ComponentRender';

Writing Html in Feliz is done through the `Html` module, which provides a set of functions corresponding to HTML elements.

import HtmlExample from '../../feliz-docs/fableoutput/Examples/Feliz/Html'
import RawHtmlExample from '!!raw-loader!../../feliz-docs/Examples/Feliz/Html.fs'

<ComponentRender code={RawHtmlExample} defaultOpen>
  <HtmlExample />
</ComponentRender>

:::warning

Note that you can't mix attributes and child elements. If you use the component overload taking `IReactProperty list`, you must use `prop.children` to specify the child elements, as shown above.

However, in the specific case of a single `Html.text` child, you can also use the `prop.text` alias. The code above is the same as this:

:::

## Overloads

All `Html.*` functions take a variable number of arguments, they are defined using so called "overloads". Properties are defined in the `prop` module.

The following example showcases these overloads:

`Rightlick` and inspect on the example below to see the generated HTML.

import OverloadsExample from '../../feliz-docs/fableoutput/Examples/Feliz/Overloads'
import RawOverloadsExample from '!!raw-loader!../../feliz-docs/Examples/Feliz/Overloads.fs'

<ComponentRender code={RawOverloadsExample} defaultOpen>
  <OverloadsExample />
</ComponentRender>

:::tip[When to use which?]
You can use whichever you prefer. They should offer you the flexibility to write as much or as little boilerplate as you want.
:::

:::warning[No warnings for missing keys]
Feliz passes all children as spread argument to React.createElement. This means that React is not able to warn you about missing `key` properties on dynamic children. You need to ensure that you provide `key` properties yourself when rendering dynamic elements (e.g. in for loops, or mapping functions).

You can refer to the [official docs](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) for more information on this topic.

If you use the [Feliz.JSX](../guides/output-jsx.mdx) syntax, the compiler will warn you about missing `key` properties as it will generate compile time JSX code instead of runtime calls to `React.createElement`.
:::

## Inline styling

Inline styling can be done using the `prop.style` property. It takes a list of styles defined in the `style` module.

This module allows you to write all inline styling in a type-safe way, with autocompletion and compile-time checks.

import StylingExample from '../../feliz-docs/fableoutput/Examples/Feliz/Styling'
import RawStylingExample from '!!raw-loader!../../feliz-docs/Examples/Feliz/Styling.fs'

<ComponentRender code={RawStylingExample} defaultOpen>
  <StylingExample />
</ComponentRender>

## Examples

### Form Inputs

Input elements are dead simple to work with:

```fsharp
Html.input [
    prop.className "input"
    prop.value state.Crendentials.Password // string
    prop.onChange (SetPassword >> dispatch) // (string -> unit)
    prop.type'.password
]

Html.input [
    prop.className "input checkbox"
    prop.value state.RememberMe // boolean
    prop.onChange (SetRememberMe >> dispatch) // (bool -> unit)
    prop.type'.checkbox
]
```

Here the `onChange` property is overloaded with the following types

```fsharp
// generic onChange event
type onChange = Event -> unit
// onChange for textual input boxes
type onChange = string -> unit
// onChange for boolean input boxes, i.e. checkbox
type onChange = bool -> unit
// onChange for single file uploads
type onChange = File -> unit
// onChange for multiple file upload when prop.multiple true
type onChange = File list -> unit
// onChange for input elements where type=date or type=dateTimeLocal
type onChange = DateTime -> unit
```

### The empty element

To render the empty element, i.e. instructing React to render nothing, use `Html.none`

```fsharp
match state with
| None -> Html.none
| Some data -> render data
```

### Specifying class names

```fsharp
prop.className "button" // => "button"
prop.className [ "btn"; "btn-primary" ] // => "btn btn-primary"
```

The property `className` has overloads to combine a list of classes into a single class, convenient when your classes are bound to values so that you do not need to concatenate them yourself.

### Enhanced keyboard events

The events `prop.onKeyUp`, `prop.onKeyDown` and `onKeyPressed` are all of type `KeyboardEvent -> unit` which is correct. The input `KeyboardEvent` will contain information about the key that was pressed, its char code and whether it was pressed in combination with CTRL or SHIFT (or both). Alongside these default handlers, Feliz provides enhanced handlers that make it even _simpler_ to handle certain key presses. For example, if you have a login form and you want to dispacch `Login` message when the user hits `Enter` (very common scenario), you can do it like this:

```fsharp
Html.input [
    prop.onKeyUp (key.enter, fun _ -> dispatch Login)
    prop.onChange (UsernameChanged >> dispatch)
    prop.value state.Username
]
```

Notice the first properties `prop.onKeyUp (key.enter, fun _ -> dispatch Login)`. It takes two parameters: one is the key we are matching against and another which is of the same type as the default handlers, namely: `KeyboardEvent -> unit`. This enhanced API also allows you to easily match against combinations of keys such with `CTRL` and `SHIFT` as follows:

```fsharp
// Enter only
prop.onKeyUp (key.enter, fun _ -> dispatch Login)
// Enter + CTRL
prop.onKeyUp (key.ctrl(key.enter), fun _ -> dispatch Login)
// Enter + SHIFT
prop.onKeyUp (key.shift(key.enter), fun _ -> dispatch Login)
// Enter + CTRL + SHIFT
prop.onKeyUp (key.ctrlAndShift(key.enter), fun _ -> dispatch Login)
```

## Behind the scenes

Here I explain some of the types and abstractions used in Feliz. This info might help you navigate edge cases or develop your own abstractions on top of Feliz.

### IReactProperty

All properties in the `prop` module implement the `IReactProperty` interface. The IReactProperty interface is a marker interface, it does not contain any members. It is only used to provide a sensible level of typesafety when working with HTML properties.

```fsharp
Html.input [
    prop.className "input"
    prop.value state.Crendentials.Password // string
    prop.onChange (SetPassword >> dispatch) // (string -> unit)
    prop.type'.password
]
```

The implmentation of this interface is very simple:

```fsharp
type IReactProperty = interface end
```

As you can see it does nothing but restrict typing. Internally Feliz uses the following function to create the `prop.*` properties:

```fsharp
module PropHelper =

    let inline mkAttr (key: string) (value: obj) : IReactProperty = unbox (key, value)

// ...
[<Erase>]
type props =
    // ..
    static member inline className (value: string) = PropHelper.mkAttr "className" value

    static member inline className (names: seq<string>) = PropHelper.mkAttr "className" (String.concat " " names)

```

So all `prop.*` functions create a tuple of key and value and cast it to `IReactProperty`. This is why you can pass any property in the list of properties of an `Html.*` function, as long as it implements `IReactProperty`.

This also means that you can pass your own properties as long as they follow the (key: string, value: obj) tuple shape and implement `IReactProperty`.

```fsharp

Html.div [
  unbox<IReactProperty> ("data-custom-attr", "my-value") // custom attribute
  prop.custom("myProp", 42) // custom property using prop.custom
]

```
:::tip
The same logic is used for `IStyleAttribute` and `ISvgAttribute`
:::
